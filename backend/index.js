//new code

const express = require('express');
const bodyParser = require('body-parser');
const mysql = require('mysql');
const path = require('path');
const fs = require('fs');
const multer = require('multer');
const app = express();
const { PythonShell } = require('python-shell');
const PORT = process.env.PORT || 3000;


// Middleware
app.use(bodyParser.json());
app.use(express.static(path.join(__dirname, '../frontend')));

// MySQL Connection
const connection = mysql.createConnection({
    host: process.env.DB_HOST || 'localhost',
    user: process.env.DB_USER || 'root',
    password: process.env.DB_PASSWORD || '',
    database: process.env.DB_NAME || 'pentest_checklist',
});

connection.connect((err) => {
    if (err) {
        console.error('Error connecting to MySQL database:', err);
        process.exit(1); // Terminate the application if unable to connect to the database
    }
    console.log('Connected to MySQL database');
});

// Route to handle form submission
app.post('/submit-form', (req, res) => {
    const { projectName, sbu, projectOwner, protocols, startDate, endDate } = req.body;

    // Create folder structure
    const userFolder = path.join('./Pentest-Checklist/', projectOwner, sbu, projectName);

    // Ensure all parent directories exist before creating the final directory
    fs.mkdirSync(userFolder, { recursive: true });

    // Create folders for each protocol
    protocols.forEach(protocol => {
        const protocolFolder = path.join(userFolder, protocol);

        // Ensure all parent directories exist before creating the protocol directory
        fs.mkdirSync(protocolFolder, { recursive: true });
    });

    // Assign the project folder path to the `path` variable
    const projectFolderPath = userFolder;

    // Print the project folder path to debug
    console.log('Project Folder Path:', projectFolderPath);

    // Insert project data into MySQL database
    const insertQuery = `INSERT INTO project (project_name, sbu, project_owner, protocols, path, start_date, end_date) 
                         VALUES (?, ?, ?, ?, ?, ?, ?)`;
    const values = [projectName, sbu, projectOwner, JSON.stringify(protocols), projectFolderPath, startDate, endDate];

    // Print the INSERT query and values to debug
    console.log('Insert Query:', insertQuery);
    console.log('Values:', values);

    // Execute the INSERT query
    connection.query(insertQuery, values, (error, results, fields) => {
        if (error) {
            console.error('Error submitting form:', error);
            res.status(500).send('Internal server error');
            return;
        }

        console.log('Form submitted successfully');
        res.status(200).send('Form submitted successfully');
    });
});

// Route to fetch protocols for a project
app.get('/get-protocols', (req, res) => {
    const projectName = req.query.projectName;

    connection.query('SELECT protocols FROM project WHERE project_name = ?', [projectName], (error, results, fields) => {
        if (error) {
            console.error('Error fetching protocols:', error);
            res.status(500).send('Internal server error');
            return;
        }

        if (results.length === 0) {
            res.status(404).send('Project not found');
            return;
        }

        const protocols = JSON.parse(results[0].protocols);
        res.json(protocols);
    });
});

// Route to fetch project names
app.get('/get-projects', (req, res) => {
    connection.query('SELECT project_name FROM project', (error, results, fields) => {
        if (error) {
            console.error('Error fetching project names:', error);
            res.status(500).send('Internal server error');
            return;
        }

        const projectNames = results.map(result => result.project_name);
        res.json(projectNames);
    });
});

// Route to fetch test cases based on the selected protocol
app.get('/get-test-cases', (req, res) => {
    const protocol = req.query.protocol;

    // Fetch test cases from the 'pentest_test_cases' table based on the selected protocol
    connection.query('SELECT protocol, test_case_name,description,impact,remediation FROM pentest_test_cases WHERE protocol = ?', [protocol], (error, testCases, fields) => {
        if (error) {
            console.error('Error fetching test cases:', error);
            res.status(500).send('Internal server error');
            return;
        }

        res.json(testCases);
    });
});

// Set up multer for file uploads with destination folder as uploads and preserving original file name
const storage = multer.diskStorage({
    destination: 'uploads/',
    filename: (req, file, cb) => {
        const extension = path.extname(file.originalname);
        const filename = `${file.fieldname}-${Date.now()}${extension}`;
        cb(null, filename);

        // Save filename in the request to be used later
        req.filename = filename;
    }
});

const upload = multer({ storage });

// Route to handle file uploads
app.post('/upload-files', upload.array('files'), (req, res) => {
    const files = req.files;
    const protocol = req.body.protocol;
    const projectName = req.body.projectName;
    const testCaseName = req.body.testCaseName;
	const description = req.body.description; // Added
    const impact = req.body.impact; // Added
    const remediation = req.body.remediation; // Added
	
	console.log(description,impact,remediation);

    if (!files || files.length === 0) {
        res.status(400).json({ error: 'No files uploaded.' });
        return;
    }

    // Fetch the folder path from the database
    const projectFolderQuery = 'SELECT path FROM project WHERE project_name = ?';
    connection.query(projectFolderQuery, [projectName], (error, results, fields) => {
        if (error) {
            console.error('Error fetching project folder path:', error);
            res.status(500).json({ error: 'Internal server error' });
            return;
        }

        if (results.length === 0) {
            res.status(404).json({ error: 'Project not found' });
            return;
        }

        const projectFolderPath = results[0].path;

        // Create a folder for the protocol within the project folder
        const protocolFolderPath = path.join(projectFolderPath, protocol);

        // Ensure the protocol folder exists
        fs.mkdirSync(protocolFolderPath, { recursive: true });

        // Move each uploaded file to the protocol folder
        files.forEach(file => {
            const oldFilePath = file.path;
            const newFilePath = path.join(protocolFolderPath, file.originalname);

            // Move the file
            fs.renameSync(oldFilePath, newFilePath);

            // Insert file details into the database
            const insertFileQuery = `INSERT INTO findings (prj_name, protocol, detection_name, description,impact, remediation, file_path) 
                                     VALUES (?, ?, ?, ?, ?, ?, ?)`;
            const values = [projectName, protocol, testCaseName,description,impact,remediation, newFilePath];
			
			

            connection.query(insertFileQuery, values, (error, results, fields) => {
                if (error) {
                    console.error('Error inserting file details into the database:', error);
                }
            });
        });

        // Print the final upload path for debugging
        console.log('Files uploaded to:', protocolFolderPath);

        // Send response to the client
        res.json({ message: 'Files uploaded successfully.' });
    });
});

// Route to generate the JSON report including image data and project owner
app.post('/generate-report', async (req, res) => {
    const projectName = req.body.projectName;

    // Fetch findings for the specified project from the database along with project owner
    const fetchQuery = `
        SELECT f.prj_name, f.protocol, f.detection_name,f.description,f.impact,f.remediation, f.file_path, p.project_owner
        FROM findings f
        JOIN project p ON f.prj_name = p.project_name
        WHERE f.prj_name = ?`;
    
    connection.query(fetchQuery, [projectName], async (error, results, fields) => {
        if (error) {
            console.error('Error fetching findings:', error);
            res.status(500).send('Internal server error');
            return;
        }

        if (results.length === 0) {
            res.status(404).send('No findings found for the project');
            return;
        }

        try {
            // Iterate through each finding and fetch image data asynchronously
            for (const finding of results) {
                // Fetch image data for the current finding
                const imageData = await fetchImageData(finding.file_path);
                // Add the image data to the finding object
                finding.imageData = imageData;
            }

            // Send the findings data including image data as JSON response
            res.json(results);
        } catch (error) {
            console.error('Error generating report:', error);
            res.status(500).send('Internal server error');
        }
    });
});

// Function to fetch image data asynchronously
async function fetchImageData(filePath) {
    try {
        const imageBuffer = fs.readFileSync(filePath);
        const base64ImageData = Buffer.from(imageBuffer).toString('base64');
        return base64ImageData;
    } catch (error) {
        console.error('Error fetching image data:', error);
        return null;
    }
}
// Route for report generation
app.get('/generate-report', (req, res) => {
    const projectName = req.query.projectName;
    console.log('Project Name:', projectName); // Log the project name

    if (!projectName) {
        return res.status(400).send('Project name is required');
    }

    // Run the Python script with project name as argument
    PythonShell.run('generate_report.py', { args: [projectName] }, (err, result) => {
        if (err) {
            console.error(err);
            res.status(500).send('Error generating report');
        } else {
            // Assuming the message is the first item in the result array
            const message = result && result[0];
            console.log('Report generation result:', message); // Log the report generation result
            res.send('Report generated successfully'); // Send the message to the frontend
        }
    });
});
// download report
app.get('/download-report', (req, res) => {
    const projectName = req.query.projectName;

    // Connect to the MySQL database
    const connection = mysql.createConnection({
        host: 'localhost',
        user: 'root',
        password: '',
        database: 'pentest_checklist'
    });

    // Query to fetch report details based on the project name
    const query = `SELECT report_path FROM reports WHERE project_name = ?`;

    // Execute the query
    connection.query(query, [projectName], (err, results) => {
        if (err) {
            console.error('Error fetching report details:', err);
            res.status(500).send('Error fetching report details');
            return;
        }

        if (results.length === 0) {
            res.status(404).send('Report not found');
            return;
        }

        // Extract report path from the results
        const reportPath = results[0].report_path;

        // Construct the file path
        const filePath = path.join(__dirname, reportPath);
		console.log(filePath);
        // Trigger file download
        res.download(filePath, 'report.docx', (err) => {
            if (err) {
                console.error('Error downloading report:', err);
                res.status(500).send('Error downloading report');
            } else {
                console.log('Report downloaded successfully');
            }
        });

        // Close the database connection
        connection.end();
    });
});





// Start the server
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});